<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rsyslog—日志及集中化管理</title>
      <link href="/2020/03/07/rsyslog-%E6%97%A5%E5%BF%97%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/03/07/rsyslog-%E6%97%A5%E5%BF%97%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="rsyslogd—日志及集中化管理"><a href="#rsyslogd—日志及集中化管理" class="headerlink" title="rsyslogd—日志及集中化管理"></a>rsyslogd—日志及集中化管理</h1><h2 id="rsyslog-简介"><a href="#rsyslog-简介" class="headerlink" title="rsyslog 简介"></a>rsyslog 简介</h2><p>rsyslog 在Linux上自带，兼容syslog语法，在syslog基础上增加了更多协议的支持，配合额外module插件可以完成很多场景的使用。借用下官网的图片：</p><p><img src="640.png" alt="rsyslogd—日志及集中化管理"><br><img src="640.png" alt="/opt/blog/source/img/rsyslog-日志集中化管理工具"></p><p>注： Windows 平台需要 nxlog （nxlog 是用C 语言写的一个跨平台日志收集处理软件）。</p><p>最近遇到一个需求，需要把线上环境的debug日志及集中化收集起来，一方面是方便开发调试；一方面是避免直接到线上环境查看，存在安全隐患。</p><h2 id="常用可选方案"><a href="#常用可选方案" class="headerlink" title="常用可选方案"></a>常用可选方案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rsyslog发送端 + rsyslog接收端： 直接存在接收端的本地硬盘</span><br><span class="line"></span><br><span class="line">rsyslog发送端 + logstash接收端 + &lt;后续第三方处理&gt;： 接受到log更新行后，通过logstash简单处理后，可以继续往第三方处理，如放到ElasticSearch，或者放到消息队列Kfaka等</span><br><span class="line"></span><br><span class="line">rsyslog发送端 + Splunk： Splunk是商业软件，也是业内用的比较多的方式，价格不菲</span><br></pre></td></tr></table></figure><p>基本原理和处理流程都是类似的： 监控本地log文件内容的变化，然后把变化的文件内容发送到远端收集服务上。</p><p>例如常说的ELKstack（ElasticSearch+Logstash+Kibana）的第一步都是配置rsyslog发送端。</p><p>不管哪种方案都得监控本地文件的变化，rsyslog属于必选。我们需求比较简单，暂时选用了落地到本地盘，默认存储15天debug日志。</p><p>本文主要介绍rsyslog发送端、接收端的配置，以及遇到的一些坑。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在CentOS 6.8 Final 上自带的版本为 5.8.10。如需最新版本，可参考官网。</p><p> <a href="http://www.rsyslog.com" target="_blank" rel="noopener">http://www.rsyslog.com</a> </p><p>V5版本开发于2010年，属于比较旧的版本，最新版本是V8，支持了更多的字符串处理函数和更多module，当然性能也更好。</p><p>缺点是：新旧配置语法不兼容，而采用内置版本的另一个偷懒的好处是云端的镜像也不需要再额外升级，能支持更多老机器。</p><p>后面介绍以V5版本为例，如有不同的，会单独指出。</p><h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/sbin/rsyslogd : 执行文件</span><br><span class="line"></span><br><span class="line">/etc/rsyslog.conf : 主配置文件:</span><br><span class="line"></span><br><span class="line">/etc/rsyslog.d/*.conf : 自定义配置文件</span><br><span class="line"></span><br><span class="line">/etc/init.d/rsyslog restart : 修改配置文件后，重启服务</span><br></pre></td></tr></table></figure><h2 id="一份配置文件主要包括以下几个部分"><a href="#一份配置文件主要包括以下几个部分" class="headerlink" title="一份配置文件主要包括以下几个部分"></a>一份配置文件主要包括以下几个部分</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MODULES</span><br><span class="line">RULES</span><br><span class="line">全局指令，模板，模块参数等</span><br></pre></td></tr></table></figure><p>自带的配置文件如下，参考后面的注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rsyslog v5 configuration file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### MODULES #### # 模块放在开头加载</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ModLoad imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command) # 可以用来调试，稍后有例子</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ModLoad imklog <span class="comment"># provides kernel logging support (previously done by rklogd)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ModLoad</span> immark <span class="comment"># provides --MARK-- message capability</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides UDP syslog reception</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ModLoad</span> imudp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$UDPServerRun</span> 514</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides TCP syslog reception <span class="comment"># TCP server，接收端需要加载这个模块，发送端不需要</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ModLoad</span> imtcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$InputTCPServerRun</span> 514</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### GLOBAL DIRECTIVES ####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use default timestamp format</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat <span class="comment"># 消息格式</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> File syncing capability is disabled by default. This feature is usually not required,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> not useful and an extreme performance hit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ActionFileEnableSync</span> on</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### RULES #### # 用来指定哪种类型的，哪种级别的log，发送给谁处理</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Log all kernel messages to the console.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Logging much <span class="keyword">else</span> clutters up the screen.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kern.* /dev/console</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Log anything (except mail) of level info or higher.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Don<span class="string">'t log private authentication messages!</span></span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none /var/log/messages</span><br><span class="line"><span class="meta">#</span><span class="bash"> The authpriv file has restricted access.</span></span><br><span class="line">authpriv.* /var/log/secure</span><br><span class="line"><span class="meta">#</span><span class="bash"> Log all the mail messages <span class="keyword">in</span> one place.</span></span><br><span class="line">mail.* -/var/log/maillog # '-' 表示异步</span><br><span class="line"><span class="meta">#</span><span class="bash"> Log cron stuff</span></span><br><span class="line">cron.* /var/log/cron</span><br><span class="line"><span class="meta">#</span><span class="bash"> Everybody gets emergency messages</span></span><br><span class="line">*.emerg *</span><br><span class="line"><span class="meta">#</span><span class="bash"> Save news errors of level crit and higher <span class="keyword">in</span> a special file.</span></span><br><span class="line">uucp,news.crit /var/log/spooler</span><br><span class="line"><span class="meta">#</span><span class="bash"> Save boot messages also to boot.log</span></span><br><span class="line">local7.* /var/log/boot.log # local开头的是自定义的日志类型</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">### begin forwarding rule ###</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The statement between the begin ... end define a SINGLE forwarding</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rule. They belong together, <span class="keyword">do</span> NOT split them. If you create multiple</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> forwarding rules, duplicate the whole block!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Remote Logging (we use TCP <span class="keyword">for</span> reliable delivery)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> An on-disk queue is created <span class="keyword">for</span> this action. If the remote host is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> down, messages are spooled to disk and sent when it is up again.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$WorkDirectory</span> /var/lib/rsyslog <span class="comment"># where to place spool files</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ActionQueueFileName</span> fwdRule1 <span class="comment"># unique name prefix for spool files</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ActionQueueMaxDiskSpace</span> 1g <span class="comment"># 1gb space limit (use as much as possible)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ActionQueueSaveOnShutdown</span> on <span class="comment"># save messages to disk on shutdown</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ActionQueueType</span> LinkedList <span class="comment"># run asynchronously</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ActionResumeRetryCount</span> -1 <span class="comment"># infinite retries if host is down</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional</span></span><br><span class="line"><span class="meta">#</span><span class="bash">*.* @@remote-host:514</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">### end of the forwarding rule ###</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Finally include all config files <span class="keyword">in</span> /etc/rsyslog.d. This allows overrides</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of the default configuration above.</span></span><br><span class="line"><span class="meta">$</span><span class="bash">IncludeConfig /etc/rsyslog.d/*.conf <span class="comment"># 这里会自动加载自定义的*.conf配置文件，可以覆盖默认参数</span></span></span><br></pre></td></tr></table></figure><h2 id="模块-imfile"><a href="#模块-imfile" class="headerlink" title="模块 imfile"></a>模块 imfile</h2><p>为了完成我们的任务，除了上面默认的模块，还需要加载 imfile，,来指定监控哪些文件，参考文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ModLoad imfile <span class="comment"># Load the imfile input module</span></span></span><br></pre></td></tr></table></figure><p>该模块把标准的文本文件转换成syslog的message格式， 所谓标准文本是指：保护可打印的字符，每行以 LF作为分隔符号。 支持文件正在在logrotate的时候，仍能正确处理。</p><p>它会把监控文件的读取到哪一个位置（类似游标cursor），存储在state文件里（由 $WorkDirectory 指定）。</p><p>该模块支持如下指令，一组如下设置，可以称为一个 <strong>listener</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">InputFileName /path/to/file <span class="comment"># 待监控的文件路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileTag tag <span class="comment"># 文件唯一标识tag，最好保持唯一，用于接收端区分原始log文件，可以包含特殊字符，如":"、","等</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileStateFile /path/to/state/file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 【重要】需要保证发送端唯一，记录读取到哪儿，状态文件保存在<span class="variable">$WorkDirectory</span>，默认为 /var/lib/rsyslog</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果某个要监控的文件名变化了，一定要重新设置该值</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileFacility facility <span class="comment"># log类型，默认local0， local开头的表示自定义类型</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileSeverity severity <span class="comment"># log级别：info，warning，默认notice</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputRunFileMonitor <span class="comment"># 启动监控当前的文件，如果忘记这行，则啥事也不会发生</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFilePollInterval seconds <span class="comment"># 全局设置，默认轮询是10s</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFilePersistStateInterval lines <span class="comment"># 每多少行更新state文件状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileReadMode mode <span class="comment"># 官网竟然没这个解释，不过也没用到。。。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileMaxLinesAtOnce number</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认10240，如果在发送端，需要同时监控多个文件，会处理完当前文件特定行后，切换到下一个文件，避免一个文件一直占用处理，导致收集别的文件不及时。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileBindRuleset ruleset <span class="comment"># 属于较高级的设置，可以把这个listener绑定到特点的规则(http://www.rsyslog.com/doc/v5-stable/concepts/multi_ruleset.html)</span></span></span><br></pre></td></tr></table></figure><p>接收端配置，注意tag里的逗号 <strong>‘,’</strong>，稍后在接收端，会它来分隔：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For product, total 19 files.</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileName /Data/logs/product/cache-Statistic.log</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileTag product,cache-Statistic</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileSeverity info</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileStateFile state_product_cache-Statistic</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFilePersistStateInterval 25000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileFacility local5</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputRunFileMonitor</span></span><br></pre></td></tr></table></figure><h2 id="Rule-设置"><a href="#Rule-设置" class="headerlink" title="Rule 设置"></a>Rule 设置</h2><p>一条rule的语法格式如： <Facility>.<Severity> <Target></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Log cron stuff</span></span><br><span class="line">cron.* /var/log/cron</span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录info到本地messages文件，.none 结尾表示排除掉这些文件类型。</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none /var/log/messages</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有为local5的任意级别日志发送到远端514</span></span><br><span class="line">local5.* @@192.168.56.10:514</span><br></pre></td></tr></table></figure><h2 id="Facility"><a href="#Facility" class="headerlink" title="Facility"></a>Facility</h2><p>日志设备(可以理解为日志类型):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">auth #pam产生的日志，认证日志</span><br><span class="line">authpriv #ssh,ftp等登录信息的验证信息，认证授权认证</span><br><span class="line">cron #时间任务相关</span><br><span class="line">kern #内核</span><br><span class="line">lpr #打印</span><br><span class="line">mail #邮件</span><br><span class="line">mark(syslog) #rsyslog服务内部的信息,时间标识</span><br><span class="line">news #新闻组</span><br><span class="line">user #用户程序产生的相关信息</span><br><span class="line">uucp #unix to unix copy, unix主机之间相关的通讯</span><br><span class="line">local 1~7 #自定义的日志设备</span><br></pre></td></tr></table></figure><h2 id="Severity"><a href="#Severity" class="headerlink" title="Severity"></a>Severity</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">debug #有调式信息的，日志信息最多</span><br><span class="line">info #一般信息的日志，最常用</span><br><span class="line">notice #最具有重要性的普通条件的信息</span><br><span class="line">warning, warn #警告级别</span><br><span class="line">err, error #错误级别，阻止某个功能或者模块不能正常工作的信息</span><br><span class="line">crit #严重级别，阻止整个系统或者整个软件不能正常工作的信息</span><br><span class="line">alert #需要立刻修改的信息</span><br><span class="line">emerg, panic #内核崩溃等严重信息</span><br></pre></td></tr></table></figure><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件： /var/log/messages</span><br><span class="line"></span><br><span class="line">用户： root，*（表示所有用户）， 会发到/var/spool/mail/收件箱里</span><br><span class="line"></span><br><span class="line">日志服务器： @192.168.56.10 或者 @@192.168.56.10</span><br><span class="line"></span><br><span class="line">管道： | COMMAND</span><br><span class="line"></span><br><span class="line">一个 @ 表示 UDP, 两个 @@ 表示 TCP 协议。</span><br></pre></td></tr></table></figure><h2 id="模板-template"><a href="#模板-template" class="headerlink" title="模板$template"></a>模板$template</h2><p>模板 $template， 最主要的一个指令，在 接收端 可用来定义消息格式、文件名。主要是在接收端使用。</p><p>可参考 官方文档Templates</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">template &lt;name&gt;,&lt;内容&gt;,&lt;可选项&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template MyTemplateName,<span class="string">"\7Text %property% some more text\n"</span>,&lt;options&gt;</span></span><br></pre></td></tr></table></figure><p>默认的消息格式 RSYSLOG_TraditionalFileFormat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;接收内容的时间&gt; &lt;发送者的hostname&gt; &lt;$InputFileTag&gt; &lt;原始消息%msg%&gt;</span><br><span class="line">Dec 18 20:39:27 jumper-172-31-56-18 karltestdemoTag blala... dummy msg</span><br></pre></td></tr></table></figure><p>如果只需要显示原始消息，可设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">template CleanMsgFormat,<span class="string">"%msg%\n"</span></span></span><br></pre></td></tr></table></figure><h2 id="内置属性-Properties"><a href="#内置属性-Properties" class="headerlink" title="内置属性 Properties"></a>内置属性 Properties</h2><p>模板里支持一些 内置的变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">msg%</span></span><br><span class="line"><span class="meta">%</span><span class="bash">syslogfacility%</span></span><br><span class="line"><span class="meta">%</span><span class="bash">HOSTNAME%</span></span><br><span class="line"><span class="meta">%</span><span class="bash">syslogpriority%</span></span><br><span class="line"><span class="meta">%</span><span class="bash">timereported:::date-mysql%</span></span><br><span class="line"><span class="meta">%</span><span class="bash">timegenerated:::date-mysql%</span></span><br><span class="line"><span class="meta">%</span><span class="bash">iut%</span></span><br><span class="line">'%syslogtag%'</span><br></pre></td></tr></table></figure><h2 id="属性处理-Property-Replacer"><a href="#属性处理-Property-Replacer" class="headerlink" title="属性处理 Property Replacer"></a>属性处理 Property Replacer</h2><p>Property Replacer 用来处理变量，支持一些简单的字符串处理，如大小写，substring等，类似jinja2的filter概念。</p><p>版本越新支持的处理函数越强大。</p><p>语法： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">property:fromChar:toChar:options%</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For product</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template productFileFormat,<span class="string">"/Data/logs/product/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="variable">$YEAR</span>%%<span class="variable">$MONTH</span>%%<span class="variable">$DAY</span>%.log"</span></span></span><br><span class="line">if $syslogtag startswith 'product' then ?productFileFormat;CleanMsgFormat</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><p>上面的例子，在接收端会保存为 /Data/logs/product/198.168.56.123/karltest_demo-20161218.log</p><p>解释下这个指令%syslogtag:F,44:2%</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F : - 代表自定义一个分隔符</span><br><span class="line"></span><br><span class="line">44 : - 是逗号 , 的 ASCII 码值，如需要别的分隔符，需要查对应 ASCII 值</span><br><span class="line"></span><br><span class="line">2 : - 取分隔后的第二个字段</span><br></pre></td></tr></table></figure><p>所以就是： 假设发送端自定义的tag为 $InputFileTag product,karltest_demo，</p><p>如果tag以product开始，则取出逗号分隔的第二个字段作为保存的文件名，这也是为啥上面tag里要设置一个逗号的缘故。</p><p>另外，还支持一定的 regex 语法，可以进行更高级的控制。官方提供了一个在线的 regex 语法测试。</p><p><em>友情提醒：真的很难用。。。</em></p><h2 id="停止指令"><a href="#停止指令" class="headerlink" title="停止指令"></a>停止指令</h2><p>上面的接收端，在一条规则后，加上了如下的指令（也叫停止指令），代表如果log被当前的rule已经处理过了，则完成本次执行，跳过后续rule的处理。 类似 C++里 switch/case，如果忘记加break的穿透副作用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><p>如果没有这个指令，则一条新来的消息可以被多个rule处理。 这里我们并不需要，只要命中就保存到接收端同名的文件里。</p><h2 id="发送端配置"><a href="#发送端配置" class="headerlink" title="发送端配置"></a>发送端配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 加载 imfile 模块</span><br><span class="line">2. 指定要监控的 log 文件路径，设置合适的tag</span><br><span class="line">3. 指定远端的接收端的地址</span><br></pre></td></tr></table></figure><p>完整配置： /etc/rsyslog.conf 和 /etc/rsyslog.d/product.conf</p><h1 id="接收端配置"><a href="#接收端配置" class="headerlink" title="接收端配置"></a>接收端配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 加载 imtcp 模块</span><br><span class="line">2. 设置 message 格式</span><br><span class="line">3. 设置 文件存储路径，文件名格式</span><br></pre></td></tr></table></figure><p>完整配置： /etc/rsyslog.conf</p><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><h4 id="UDP-or-TCP"><a href="#UDP-or-TCP" class="headerlink" title="UDP or TCP ?"></a>UDP or TCP ?</h4><p>一般来说选择TCP都是OK的，除非忍受部分丢失，在意影响性能，可以改用UDP。</p><p>但是注意：如果你的消息每行大小超过了4k，只能用TCP。这是因为UDP栈大小限制的。</p><p>引用官方有关 MaxMessageSize 的描述：</p><blockquote><p>Note: testing showed that 4k seems to be the typical maximum for UDP based syslog. This is an IP stack restriction. Not always … but very often. If you go beyond that value, be sure to test that rsyslogd actually does what you think it should do ;) It is highly suggested to use a TCP based transport instead of UDP (plain TCP syslog, RELP). This resolves the UDP stack size restrictions.</p></blockquote><h4 id="如何测试：-vim-vs-echo"><a href="#如何测试：-vim-vs-echo" class="headerlink" title="如何测试： vim vs echo ?"></a>如何测试： vim vs echo ?</h4><p>配置好接收端、发送端rsyslog后，需要验证下是否能正确传送新的log行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. echo追加： echo "dummy message" &gt;&gt; /Data/logs/product/karltest.log</span><br><span class="line">2. vim编辑： vim /Data/logs/product/karltest.log</span><br></pre></td></tr></table></figure><p>用vim编辑后，保存会刷新整个文件，导致rsyslog在比较state file的时候，认为全部是新增的行，会在接收端出现重复的log行。</p><p>所以正确测试方法是用 echo 追加的方式。</p><blockquote><p>Tips:</p><p>发送端：可以配合 watch 来测试： watch -n 1 “ echo $(date) dummy message &gt;&gt; /Data/logs/product/karltest.log “</p><p>接收端： tailf /Data/logs/karltest/karltest.log</p></blockquote><h4 id="接收端：log行太长，被截断了"><a href="#接收端：log行太长，被截断了" class="headerlink" title="接收端：log行太长，被截断了"></a>接收端：log行太长，被截断了</h4><p>默认大小是2k，大概可以保存1000个中文字符，参考官方说明 $MaxMessageSize， 最小也是2k。</p><p>在加载imtcp/imudp之前设置， 此配置包括发送和接收，所以rsyslog客户端、服务端都要设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">MaxMessageSize 32k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides TCP syslog reception</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$ModLoad</span> imtcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$InputTCPServerRun</span> 514</span></span><br></pre></td></tr></table></figure><h4 id="发送端：-var-log-messages-文件变大"><a href="#发送端：-var-log-messages-文件变大" class="headerlink" title="发送端：/var/log/messages 文件变大"></a>发送端：/var/log/messages 文件变大</h4><p>log除了发送到了接收端，还在本地 /var/log/messages 里重复出现了，导致messages上G</p><p>罪魁祸首是默认的配置文件如下这行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改前</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none /var/log/messages</span><br><span class="line"><span class="meta">#</span><span class="bash"> Fix后</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none;local5.none;local6.none /var/log/messages</span><br></pre></td></tr></table></figure><p>因为前面有通配符 *.info 导致我们自定义的 local5.info 也会写到本地messages文件。</p><p>为了保险，请把接收端、发送端的配置文件都修改掉，忽略掉local5。</p><h4 id="接收端：消息被多个rule处理"><a href="#接收端：消息被多个rule处理" class="headerlink" title="接收端：消息被多个rule处理"></a>接收端：消息被多个rule处理</h4><p>在命中某条rule后，直接break停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if $syslogtag startswith 'product' then ?productFileFormat;CleanMsgFormat</span><br><span class="line">&amp; ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新版本v6之后，变为：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rsyslogd: warning: ~ action is deprecated, consider using the <span class="string">'stop'</span> statement instead [try http://www.rsyslog.com/e/2307 ]</span></span><br><span class="line">if $syslogtag startswith 'product' then ?productFileFormat;CleanMsgFormat</span><br><span class="line">stop</span><br></pre></td></tr></table></figure><h4 id="接收端：-保存的文件路径不对"><a href="#接收端：-保存的文件路径不对" class="headerlink" title="接收端： 保存的文件路径不对"></a>接收端： 保存的文件路径不对</h4><p>要注意自定义tag的前缀匹配，如果两个tag有共同的前缀，需要把长的放在前面，调整好顺序。</p><p>Fix 前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For erp_wms</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template erp_wms_FileFormat,<span class="string">"/Data/logs/erp/wms/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="variable">$YEAR</span>%%<span class="variable">$MONTH</span>%%<span class="variable">$DAY</span>%.log"</span></span></span><br><span class="line">if $syslogtag startswith 'erp_wms' then ?erp_wms_FileFormat;CleanMsgFormat</span><br><span class="line">&amp; ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> For erp_wms3</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template erp_wms3_FileFormat,<span class="string">"/Data/logs/erp/wms3/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="variable">$YEAR</span>%%<span class="variable">$MONTH</span>%%<span class="variable">$DAY</span>%.log"</span></span></span><br><span class="line">if $syslogtag startswith 'erp_wms3' then ?erp_wms3_FileFormat;CleanMsgFormat</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><p>Fix 后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里注意下面的tag的顺序， 一定要让长的tag（erp_wms3）保持在上面，因为他们有共同的前缀(erp_wms)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For erp_wms3</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template erp_wms3_FileFormat,<span class="string">"/Data/logs/erp/wms3/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="variable">$YEAR</span>%%<span class="variable">$MONTH</span>%%<span class="variable">$DAY</span>%.log"</span></span></span><br><span class="line">if $syslogtag startswith 'erp_wms3' then ?erp_wms3_FileFormat;CleanMsgFormat</span><br><span class="line">&amp; ~</span><br><span class="line"><span class="meta">#</span><span class="bash"> For erp_wms</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template erp_wms_FileFormat,<span class="string">"/Data/logs/erp/wms/%fromhost-ip%/%syslogtag:F,44:2%-%<span class="variable">$YEAR</span>%%<span class="variable">$MONTH</span>%%<span class="variable">$DAY</span>%.log"</span></span></span><br><span class="line">if $syslogtag startswith 'erp_wms' then ?erp_wms_FileFormat;CleanMsgFormat</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><h4 id="接收端：-rsyslog-文件名太长后被截断"><a href="#接收端：-rsyslog-文件名太长后被截断" class="headerlink" title="接收端： rsyslog 文件名太长后被截断"></a>接收端： rsyslog 文件名太长后被截断</h4><p>比如发送端原始文件名tag: product，cache_status_im_request.log</p><p>但是到了接收端就截断了： cache_status_im_re-20161218.log</p><p>因为本来名字就长，加上了时间后更长了，</p><p>个人理解，Linux中关于文件名（255），文件路径（4096）的限制如下，而在接收端，都没有超过这个长度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /usr/include/linux/limits.h</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ifndef _LINUX_LIMITS_H</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define _LINUX_LIMITS_H</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define NR_OPEN         1024</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define NGROUPS_MAX    65536    /* supplemental group IDs are available */</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define ARG_MAX       131072    /* <span class="comment"># bytes of args + environ for exec() */</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define LINK_MAX         127    /* <span class="comment"># links a file may have */</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define MAX_CANON        255    /* size of the canonical input queue */</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define MAX_INPUT        255    /* size of the <span class="built_in">type</span>-ahead buffer */</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define NAME_MAX         255    /* <span class="comment"># chars in a file name */</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define PATH_MAX        4096    /* <span class="comment"># chars in a path name including nul */</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define PIPE_BUF        4096    /* <span class="comment"># bytes in atomic write to a pipe */</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define XATTR_NAME_MAX   255    /* <span class="comment"># chars in an extended attribute name */</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define XATTR_SIZE_MAX 65536    /* size of an extended attribute value (64k) */</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define XATTR_LIST_MAX 65536    /* size of extended attribute namelist (64k) */</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define RTSIG_MAX         32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br></pre></td></tr></table></figure><p>进过一番艰难的测试复现，猜测是 $InputFileTag 这个 %syslogtag%的原因。</p><p>官方解释Sending messages with tags larger than 32 characters。</p><p>发送端默认的模板为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 忽略旧的5.8.6的语法</span></span><br><span class="line">template (name="ForwardFormat" type="string" string="&lt;%PRI%&gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME%</span><br><span class="line"><span class="meta">%</span><span class="bash">syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%<span class="string">")</span></span></span><br></pre></td></tr></table></figure><p>可以看到 %syslogtag:1:32%，被截断到32字符，这个也与我测试的结果一致。</p><p>所以如果需要处理更长的tag，需要修改 发送端的template模板，去掉 :1:32 限制。</p><p>然后绑定这个模板到对应的target上。</p><p>注意：接收端可能也要相应处理，才能handle更长的tag名（未测试）。</p><blockquote><p>免责声明：由于折腾这个rsyslog太累，最后一条暂时没有Fix，如有需要，请自行测试后再用。</p></blockquote><h4 id="如下的两个-syslogtag-，由于前32个字符都相同，导致最后日志写到同一个文件-databas-log-按照逗号切割后-了"><a href="#如下的两个-syslogtag-，由于前32个字符都相同，导致最后日志写到同一个文件-databas-log-按照逗号切割后-了" class="headerlink" title="如下的两个%syslogtag%，由于前32个字符都相同，导致最后日志写到同一个文件 databas.log (按照逗号切割后)了"></a>如下的两个%syslogtag%，由于前32个字符都相同，导致最后日志写到同一个文件 databas.log (按照逗号切割后)了</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">InputFileName /Data/logs/mqorder/order-mq-aws/database-stat.log</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileTag erp_mqorder-order-mq-aws,database-stat <span class="comment"># 长度39</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileName /Data/logs/mqorder/order-mq-aws/database-timeout.log</span></span><br><span class="line"><span class="meta">$</span><span class="bash">InputFileTag erp_mqorder-order-mq-aws,database-timeout <span class="comment"># 长度42</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="解决方法-："><a href="#解决方法-：" class="headerlink" title="解决方法 ："></a>解决方法 ：</h4><p>在发送端的主配置文件 /etc/rsyslog.conf里修改发送规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">### begin forwarding rule ###</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">template LongTagForwardFormat,<span class="string">"&lt;%PRI%&gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg%"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">WorkDirectory /var/lib/rsyslog <span class="comment"># where to place spool files</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionQueueFileName karlzhou_fwdRule <span class="comment"># unique name prefix for spool files</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionQueueMaxDiskSpace 5g <span class="comment"># 5gb space limit (use as much as possible)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionQueueSaveOnShutdown on <span class="comment"># save messages to disk on shutdown</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionQueueType LinkedList <span class="comment"># run asynchronously</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ActionResumeRetryCount -1 <span class="comment"># infinite retries if host is down</span></span></span><br><span class="line">local5.* @@rsyslog.karlzhou.org:514;LongTagForwardFormat</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">### end of the forwarding rule ###</span></span></span><br></pre></td></tr></table></figure><p>其中起作用的就是 LongTagForwardFormat 这个模板。</p><h4 id="解决过程-："><a href="#解决过程-：" class="headerlink" title="解决过程 ："></a>解决过程 ：</h4><p>参考了上面的链接: 官方解释Sending messages with tags larger than 32 characters 和 tag getting truncated。</p><p>官方解释里是 5.8.6 的旧的语法，而CentOS6.x Final上自带的是 5.8.10， 语法不一样。</p><p>从官网下载5.8.10的源码: <a href="http://www.rsyslog.com/files/download/rsyslog/rsyslog-5.8.10.tar.gz" target="_blank" rel="noopener">http://www.rsyslog.com/files/download/rsyslog/rsyslog-5.8.10.tar.gz</a></p><p>全文搜索关键字 %syslogtag， 最终在如下几个文件找到蛛丝马迹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rsyslog-5.8.10/tools/smfwd.c</span><br><span class="line"></span><br><span class="line">rsyslog-5.8.10/tools/smtradfile.c</span><br><span class="line"></span><br><span class="line">rsyslog-5.8.10/tools/smtradfwd.c</span><br><span class="line"></span><br><span class="line">rsyslog-5.8.10/tools/syslogd.c</span><br><span class="line"></span><br><span class="line">全文搜索关键字 ForwardFormat:</span><br><span class="line"></span><br><span class="line">rsyslog-5.8.10/tools/syslogd.c</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* hardcoded standard templates (used for defaults) */</span><br><span class="line">static uchar template_DebugFormat[] = "\"Debug line with all properties:\nFROMHOST: '%FROMHOST%', fromhost-ip: '%fromhost-ip%', HOSTNAME: '%HOSTNAME%', PRI: %PRI%,\nsyslogtag '%syslogtag%', programname: '%programname%', APP-NAME: '%APP-NAME%', PROCID: '%PROCID%', MSGID: '%MSGID%',\nTIMESTAMP: '%TIMESTAMP%', STRUCTURED-DATA: '%STRUCTURED-DATA%',\nmsg: '%msg%'\nescaped msg: '%msg:::drop-cc%'\ninputname: %inputname% rawmsg: '%rawmsg%'\n\n\"";</span><br><span class="line">static uchar template_SyslogProtocol23Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% %PROCID% %MSGID% %STRUCTURED-DATA% %msg%\n\"";</span><br><span class="line">static uchar template_TraditionalFileFormat[] = "=RSYSLOG_TraditionalFileFormat";</span><br><span class="line">static uchar template_FileFormat[] = "=RSYSLOG_FileFormat";</span><br><span class="line">static uchar template_ForwardFormat[] = "=RSYSLOG_ForwardFormat";</span><br><span class="line">static uchar template_TraditionalForwardFormat[] = "=RSYSLOG_TraditionalForwardFormat";</span><br><span class="line">static uchar template_WallFmt[] = "\"\r\n\7Message from syslogd@%HOSTNAME% at %timegenerated% ...\r\n %syslogtag%%msg%\n\r\"";</span><br><span class="line">static uchar template_StdUsrMsgFmt[] = "\" %syslogtag%%msg%\n\r\"";</span><br><span class="line">static uchar template_StdDBFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, '%HOSTNAME%', %syslogpriority%, '%timereported:::date-mysql%', '%timegenerated:::date-mysql%', %iut%, '%syslogtag%')\",SQL";</span><br><span class="line">static uchar template_StdPgSQLFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, '%HOSTNAME%', %syslogpriority%, '%timereported:::date-pgsql%', '%timegenerated:::date-pgsql%', %iut%, '%syslogtag%')\",STDSQL";</span><br><span class="line">static uchar template_spoofadr[] = "\"%fromhost-ip%\"";</span><br><span class="line">/* end templates */</span><br></pre></td></tr></table></figure><p>正如官网链接所说，源码里 hardcoded 里多个默认模板格式，</p><p>其中我们需要关注的就是 RSYSLOG_ForwardFormat, 对应的文件即：rsyslog-5.8.10/tools/smfwd.c。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* smfwd.c</span><br><span class="line">* This is a strgen module for the traditional (network) forwarding format.</span><br><span class="line">*</span><br><span class="line">* Format generated:</span><br><span class="line">* "&lt;%PRI%&gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%"</span><br><span class="line">*</span><br><span class="line">* NOTE: read comments in module-template.h to understand how this file</span><br><span class="line">* works!</span><br><span class="line">*</span><br><span class="line">* File begun on 2010-06-01 by RGerhards</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>这里，就能找到我们需要的正确的默认格式了, 可以看到 %syslogtag% 截取了前面32个字符，把ForwardFormat规则替换成完整的 %syslogtag% 即可，注意：最大的长度是512。</p><h4 id="接下来……"><a href="#接下来……" class="headerlink" title="接下来……"></a>接下来……</h4><p>通过一番设置，我们已经能成功收集若干台线上机器的日志了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree -I <span class="string">"*gz|*log"</span> /Data/logs/</span></span><br><span class="line">/Data/logs/</span><br><span class="line">├── gateway</span><br><span class="line">│   ├── 172.31.70.18</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   ├── 172.31.70.19</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   ├── 172.31.70.195</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   ├── 172.31.70.197</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   ├── 172.31.70.198</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   └── 172.31.70.20</span><br><span class="line">│   └── archived</span><br><span class="line">├── product</span><br><span class="line">│   ├── 172.31.70.118</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   ├── 172.31.70.119</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   ├── 172.31.70.23</span><br><span class="line">│   │   └── archived</span><br><span class="line">│   └── 172.31.70.24</span><br><span class="line">│   └── archived</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> du -sh /Data/logs</span></span><br><span class="line">271G /Data/logs</span><br></pre></td></tr></table></figure><p>那么问题来了：</p><blockquote><p>上百台机器的上几百G的日志，怎么才能避免接收端硬盘爆掉？</p></blockquote><p>得用另一个Linux自带的脚本 /usr/sbin/logrotate, 来配合 rsyslog。</p>]]></content>
      
      
      <categories>
          
          <category> Linux_command </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux_command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7-系统进程管理</title>
      <link href="/2020/03/05/Centos7-%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/05/Centos7-%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7-系统进程管理"><a href="#Centos7-系统进程管理" class="headerlink" title="Centos7-系统进程管理"></a><strong>Centos7-系统进程管理</strong></h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><strong>进程是已启动的可执行程序的运行实例，进程有以下组成部分：</strong>   </p><p><strong>已分配内存的地址空间；</strong>   </p><p><strong>安全属性，包括所有权凭据和特权；</strong>   </p><p><strong>程序代码的一个或多个执行线程；</strong>   </p><p><strong>进程状态</strong></p><p><strong>程序：</strong> 二进制文件，静态 /bin/date, /usr/sbin/httpd，/usr/sbin/sshd, /usr/local/nginx/sbin/nginx 。</p><p><strong>进程：</strong> 是程序运行的过程， 动态，有生命周期及运行状态。</p><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><p><img src="640.png" alt="/opt/blog/source/img/Centos7-系统进程管理"></p><p><strong>描述如下：</strong></p><p>父进程复制自己的地址空间（fork  <strong>[fɔ:k]</strong> 分叉）创建一个新的（子）进程结构。每个新进程分配一个唯一的进程 ID （PID），满足跟踪安全性之需。PID 和 父进程 ID （PPID）是子进程环境的元素，任何进程都可以创建子进程，所有进程都是第一个系统进程的后代。</p><p><strong>centos5或6PID为1的进程是：</strong>init   </p><p><strong>centos7 PID为1的进程是：</strong>systemd</p><p><strong>僵尸进程：</strong>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p><p><strong>用自己的话表达</strong>:父进程退出了，子进程没有退出， 那么这些子进程就没有父进程来管理了，就变成僵尸进程。</p><h2 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h2><p><strong>进程ID（PID)：</strong>是唯一的数值，用来区分进程</p><p><strong>父进程的ID（PPID)</strong></p><p><strong>启动进程的用户ID</strong>（UID）和所归属的组（GID）</p><p><strong>进程状态：</strong>状态分为运行R、休眠S、僵尸Z</p><p><strong>进程执行的优先级</strong></p><p><strong>进程所连接的终端名</strong></p><p><strong>进程资源占用：</strong>比如占用资源大小（内存、CPU占用量）</p><h2 id="使用ps查看进程工具"><a href="#使用ps查看进程工具" class="headerlink" title="使用ps查看进程工具"></a>使用ps查看进程工具</h2><h3 id="常用的参数："><a href="#常用的参数：" class="headerlink" title="常用的参数："></a>常用的参数：</h3><p><strong>a:</strong> <strong>显示跟当前终端关联的所有进程</strong></p><p><strong>u:</strong> <strong>基于用户的格式显示（</strong>U: 显示某用户ID所有的进程）</p><p><strong>x:</strong> <strong>显示所有进程，不以终端机来区分</strong></p><h3 id="常用的选项组合"><a href="#常用的选项组合" class="headerlink" title="常用的选项组合"></a>常用的选项组合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-01 ~]# ps -aux|more  ##是用BSD的格式来显示进程</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0 128148  6684 ?        Ss   11月01   0:09 /usr/lib/syste</span><br><span class="line">md/systemd --switched-root --system --deserialize 22</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    11月01   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    11月01   0:00 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0      0     0 ?        S&lt;   11月01   0:00 [kworker/0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S    11月01   0:00 [kworker/u8:0]</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S    11月01   0:00 [migration/0]</span><br><span class="line">root         8  0.0  0.0      0     0 ?        S    11月01   0:00 [rcu_bh]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        S    11月01   0:12 [rcu_sched]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S&lt;   11月01   0:00 [lru-add-drain</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#包含的信息如下</span></span></span><br><span class="line">USER:      运行进程的用户</span><br><span class="line">PID：      进程ID</span><br><span class="line"><span class="meta">%</span><span class="bash">CPU:  　　CPU占用率</span></span><br><span class="line"><span class="meta">%</span><span class="bash">MEM:      内存占用率</span></span><br><span class="line">VSZ：      占用虚拟内存</span><br><span class="line">RSS:       占用实际内存 驻留内存</span><br><span class="line">TTY：      进程运行的终端</span><br><span class="line">STAT：     进程状态     man ps (/STATE)            </span><br><span class="line">      R     运行</span><br><span class="line">      S     可中断睡眠 Sleep</span><br><span class="line">      D     不可中断睡眠</span><br><span class="line">      T     停止的进程 </span><br><span class="line">      Z     僵尸进程</span><br><span class="line">      X     死掉的进程</span><br><span class="line">      </span><br><span class="line">      Ss     s进程的领导者，父进程</span><br><span class="line">      S&lt; 　　 &lt;优先级较高的进程</span><br><span class="line">      SN     N优先级较低的进程</span><br><span class="line">      R+      +表示是前台的进程组</span><br><span class="line">      Sl     以线程的方式运行    </span><br><span class="line">START:     进程的启动时间</span><br><span class="line">TIME：     进程占用CPU的总时间</span><br><span class="line">COMMAND：  进程文件，进程名</span><br><span class="line"></span><br><span class="line">[root@docker-01 ~]# ps -ef|head  ##是用标准的格式显示进程</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 11月01 ?      00:00:09 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">root         2     0  0 11月01 ?      00:00:00 [kthreadd]</span><br><span class="line">root         3     2  0 11月01 ?      00:00:00 [ksoftirqd/0]</span><br><span class="line">root         5     2  0 11月01 ?      00:00:00 [kworker/0:0H]</span><br><span class="line">root         6     2  0 11月01 ?      00:00:00 [kworker/u8:0]</span><br><span class="line">root         7     2  0 11月01 ?      00:00:00 [migration/0]</span><br><span class="line">root         8     2  0 11月01 ?      00:00:00 [rcu_bh]</span><br><span class="line">root         9     2  0 11月01 ?      00:00:12 [rcu_sched]</span><br><span class="line">root        10     2  0 11月01 ?      00:00:00 [lru-add-drain]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#包含的信息如下</span></span></span><br><span class="line">UID: 启动这些进程的用户</span><br><span class="line">PID: 进程的ID</span><br><span class="line">PPID: 父进程的进程号</span><br><span class="line">C: 进程生命周期中的CPU利用率</span><br><span class="line">STIME: 进程启动时的系统时间</span><br><span class="line">TTY: 表明进程在哪个终端设备上运行。如果显示  ?表示与终端无关，这种进程一般是内核态进程。另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等，则表示运行在虚拟终端上的进程。</span><br><span class="line">TIME: 运行进程一共累计占用的CPU时间</span><br><span class="line">CMD: 启动的程序名称</span><br></pre></td></tr></table></figure><p><img src="/Users/huqi/Desktop/屏幕快照 2019-11-03 上午11.10.21.png" alt="屏幕快照 2019-11-03 上午11.10.21"></p><p><img src="/Users/huqi/Desktop/屏幕快照 2019-11-03 上午11.10.41.png" alt="屏幕快照 2019-11-03 上午11.10.41"></p><h3 id="对进程的指定列进行排序"><a href="#对进程的指定列进行排序" class="headerlink" title="对进程的指定列进行排序"></a>对进程的指定列进行排序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-01 ~]# ps aux --sort %cpu |less  ##升序排序</span><br><span class="line">[root@docker-01 ~]# ps aux --sort -%cpu |less  ##降序排序</span><br><span class="line">[root@docker-01 ~]# ps aux --sort rss |less</span><br><span class="line">[root@docker-01 ~]# ps aux --sort -rss |less</span><br></pre></td></tr></table></figure><h3 id="不可中断状态"><a href="#不可中断状态" class="headerlink" title="不可中断状态"></a>不可中断状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-01 ~]# tar -zcvf usr-tar.gz /usr/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##然后在另一个终端不断查看状态，由S+，R+变为D+</span></span></span><br><span class="line">[root@docker-01 ~]# ps -axu|grep tar</span><br><span class="line">root     25426  3.8  0.0 123688  1552 pts/0    R+   10:31   0:01 tar -zcvf usr-tar.gz /usr/</span><br><span class="line">root     25447  0.0  0.0 112724   984 pts/1    S+   10:31   0:00 grep --color=auto tar</span><br><span class="line">root     25426  3.8  0.0 123688  1552 pts/0    D+   10:31   0:01 tar -zcvf usr-tar.gz /usr/</span><br><span class="line">root     25447  0.0  0.0 112724   984 pts/1    S+   10:31   0:00 grep --color=auto tar</span><br></pre></td></tr></table></figure><h2 id="找出系统中使用CPU最多的进程"><a href="#找出系统中使用CPU最多的进程" class="headerlink" title="找出系统中使用CPU最多的进程"></a>找出系统中使用CPU最多的进程</h2><h3 id="运行top，-找出使用CPU最多的进程，按大写的P，可以按CPU使用率来排序显示"><a href="#运行top，-找出使用CPU最多的进程，按大写的P，可以按CPU使用率来排序显示" class="headerlink" title="运行top， 找出使用CPU最多的进程，按大写的P，可以按CPU使用率来排序显示"></a>运行top， 找出使用CPU最多的进程，按大写的P，可以按CPU使用率来排序显示</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-01 ~]# top</span><br><span class="line">top - 10:48:16 up 1 day, 18:41,  2 users,  load average: 0.00, 0.04, 0.08</span><br><span class="line">Tasks: 111 total,   2 running, 109 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 </span></span><br><span class="line">KiB Mem : 16266520 total, 11269388 free,  2162204 used,  2834928 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 13687952 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND  </span><br><span class="line">17427 kibana    20   0 2515164   1.3g  10324 S   0.7  8.3   9:05.29 node     </span><br><span class="line">17255 elastic+  20   0 4713976 308280  15708 S   0.3  1.9  11:09.30 java</span><br></pre></td></tr></table></figure><h3 id="在linux系统中一个进程，最多可以使用100-cpu对吗？"><a href="#在linux系统中一个进程，最多可以使用100-cpu对吗？" class="headerlink" title="在linux系统中一个进程，最多可以使用100%cpu对吗？"></a>在linux系统中一个进程，最多可以使用100%cpu对吗？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 10:51:24 up 61 days, 23:00,  2 users,  load average: 46.56, 48.38, 34.85</span><br><span class="line">Tasks: 267 total,   1 running, 266 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s): 96.9%us,  1.6%sy,  0.0%ni,  0.3%id,  0.0%wa,  0.5%hi,  0.5%si,  0.2%st</span><br><span class="line">Mem:  71545156k total, 71079896k used,   465260k free,    58836k buffers</span><br><span class="line">Swap:  2097148k total,        0k used,  2097148k free, 18012268k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND           </span><br><span class="line">13073 smgadmin  20   0 5451m 1.4g  21m S 130.5  2.0 184:57.92 java              </span><br><span class="line">30753 smgadmin  20   0 4801m 1.3g  21m S 92.7  2.0  20:14.24 java    </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#可以看到java（脏牛漏洞，用于提权） 进程使用130.5%</span></span></span><br></pre></td></tr></table></figure><p><strong>注</strong></p><p>如果你的4核心的cpu，你可以运行400%</p><h2 id="Isof查看进程打开的文件，打开文件的进程，进程打开的端口-TCP、UDP"><a href="#Isof查看进程打开的文件，打开文件的进程，进程打开的端口-TCP、UDP" class="headerlink" title="Isof查看进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)"></a>Isof查看进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-01 ~]# yum install lsof </span><br><span class="line">[root@docker-01 ~]# vim a.txt</span><br><span class="line">[root@docker-01 ~]# ps -axu | grep a.txt</span><br><span class="line">root     25526  0.0  0.0 151532  5200 pts/0    S+   10:55   0:00 vim a.txt</span><br><span class="line">root     25560  0.0  0.0 112724  1004 pts/1    S+   10:57   0:00 grep --color=auto a.txt</span><br><span class="line">[root@docker-01 ~]# lsof -p 25526  ##一般用于查看木马进程，在读哪些文件</span><br><span class="line">[root@docker-01 ~]# lsof -i :22  ##用于查看端口，或查看黑客开启的后门端口是哪个进程在使用</span><br></pre></td></tr></table></figure><h2 id="进程优先级nice"><a href="#进程优先级nice" class="headerlink" title="进程优先级nice"></a>进程优先级nice</h2><h3 id="进程调度及多任务"><a href="#进程调度及多任务" class="headerlink" title="进程调度及多任务"></a>进程调度及多任务</h3><p>每个CPU（或CPU核心）在一个时间点上只能处理一个进程，通过时间片技术，Linux实际能够运行的进程（和线程数）可以超<br>出实际可用的CPU及核心数量。Linux内核<strong>进程调度程序</strong>将多个进程在CPU核心上快速切换，从而给用户多个进程在同时运行的印象。</p><h3 id="相对优先级-nice"><a href="#相对优先级-nice" class="headerlink" title="相对优先级 nice"></a>相对优先级 nice</h3><p>由于不是每个进程都与其他进程同样重要，可告知<strong>进程调度程序</strong>为不同的进程使用不同的<strong>调度策略</strong>。常规系统上运行的大多<br>数进程所使用的调度策略为 <strong>SCHED_OTHER</strong> (也称为SCHED_NORMAL)，但还有其它一些调度策略用于不同的目的。</p><p>SCHED_OTHER 调度策略运行的进程的<strong>相对优先级</strong>称为进程的 nice 值，可以有40种不同级别的nice值。</p><p><img src="/Users/huqi/Desktop/屏幕快照 2019-11-03 上午11.02.25.png" alt="屏幕快照 2019-11-03 上午11.02.25"></p><p><strong>nice 值越高： 表示优先级越低，例如+19，该进程容易将CPU 使用量让给其他进程。</strong><br><strong>nice 值越低： 表示优先级越高，例如-20，该进程更不倾向于让出CPU。</strong></p><h3 id="nice启动级别的设置"><a href="#nice启动级别的设置" class="headerlink" title="nice启动级别的设置"></a>nice启动级别的设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动进程时，通常会继承父进程的 nice级别，默认为0。</span></span></span><br><span class="line">[root@docker-01 ~]# sleep 6000 &amp; </span><br><span class="line">[1] 25601</span><br><span class="line">[root@docker-01 ~]# ps axo command,pid,nice |grep sleep</span><br><span class="line">sleep 6000                  25601   0</span><br><span class="line">grep --color=auto sleep     25603   0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#指定启动级别为5</span></span></span><br><span class="line">[root@docker-01 ~]# nice -n 5 sleep 6000 &amp; </span><br><span class="line">[2] 25605</span><br><span class="line">[1]   已杀死               sleep 6000</span><br><span class="line">[root@docker-01 ~]# ps axo command,pid,nice |grep sleep</span><br><span class="line">sleep 6000                  25605   5</span><br><span class="line">grep --color=auto sleep     25607   0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#更改现有进程的nice级别</span></span></span><br><span class="line">25605 (进程 ID) 旧优先级为 5，新优先级为 -15</span><br><span class="line">[root@docker-01 ~]# ps axo command,pid,nice |grep sleep</span><br><span class="line">sleep 6000                  25605 -15</span><br><span class="line">grep --color=auto sleep     25611   0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux_application </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux_application </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
